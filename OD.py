# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OD
                                 A QGIS plugin
 OD
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-12-02
        git sha              : $Format:%H$
        copyright            : (C) 2019 by CCU
        email                : jlopez@tecnocampus.cat
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import sys
import os
import webbrowser
import urllib.request, json 
import csv
import requests
import processing
from contextlib import closing        
from os.path import expanduser
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import QAction,QMessageBox,QTableWidgetItem, QApplication, QToolBar
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.core import QgsProject
from qgis.core import QgsDataSourceUri
from qgis.core import QgsField
from qgis.core import QgsFeature
from qgis.core import QgsGeometry
from qgis.core import QgsPointXY
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.PyQt.QtWidgets import QMenu
from qgis.core import QgsVectorLayer
from qgis.core import QgsVectorFileWriter
from qgis.core import QgsLayerTreeLayer
from qgis.core import QgsCoordinateReferenceSystem
try:
    from qgis.gui import QgsGenericProjectionSelector
except ImportError:
    from qgis.gui import QgsProjectionSelectionDialog
import psycopg2
import unicodedata
import datetime
import time
from qgis.utils import iface
from PyQt5.QtSql import *
import datetime
import time

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .OD_dialog import ODDialog
import os.path

"""
Variables globals per a la connexio
i per guardar el color dels botons
"""
Versio_modul="V_Q3.200114"
Fitxer=""
progress=None
aux=False
data=None
urlCargada=False
isCSV=False

class OD:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'OD_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)
            
            
        self.dlg = ODDialog()
        
        self.dlg.bt_inici.clicked.connect(self.on_click_Inici)
        self.dlg.bt_sortir.clicked.connect(self.on_click_Sortir)
        self.dlg.btnCarregar.clicked.connect(self.on_click_Carregar)
        self.dlg.btnVeure.clicked.connect(self.on_click_Veure)
        self.dlg.radio_ws.toggled.connect(self.on_toggled_radio_ws)
        self.dlg.radio_geom.toggled.connect(self.on_toggled_radio_geom)
        self.dlg.checkbox_tots.stateChanged.connect(self.on_click_checkbox_tots)
        self.dlg.btnCrs.clicked.connect(self.selectcrs)


        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&CCU')

        
        trobat=False
        for x in iface.mainWindow().findChildren(QToolBar,'CCU'): 
            self.toolbar = x
            trobat=True
        
        if not trobat:
            self.toolbar = self.iface.addToolBar('CCU')
            self.toolbar.setObjectName('CCU')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('OD', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            #self.iface.addToolBarIcon(action)
            
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/OD/icon.png'
        self.add_action(
            icon_path,
            text='OD',
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        '''for action in self.actions:
            print(action.text())
            self.iface.removePluginMenu(
                '&OD',
                action)
            self.iface.removeToolBarIcon(action)'''
        for action in self.actions:
            self.iface.removePluginMenu('&CCU', action)
            self.toolbar.removeAction(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        self.estatInicial()
        
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
    
    def selectcrs(self):
        # Select a new CRS
        s = QSettings()
        previousselectedcrs=s.value("quickcrs/crs", 0)
        #if previousselectedcrs=="" or previousselectedcrs==0 or previousselectedcrs is None:
            #self.nocrsselected()
        global selectedcrs
        try:
            projSelector = QgsGenericProjectionSelector()
            projSelector.exec_()
            projSelector.selectedCrsId()
            selectedcrs=projSelector.selectedCrsId()
        except:
            projSelector = QgsProjectionSelectionDialog()
            projSelector.exec_()
            selectedcrsdef = projSelector.crs()
            selectedcrs=selectedcrsdef.srsid()
        if (selectedcrs=="" or selectedcrs==0 or self.CrsId2AuthID(selectedcrs)=="" or selectedcrs is None):
            #selectedcrs=previousselectedcrs
            pass
        if (selectedcrs=="" or selectedcrs==0 or self.CrsId2AuthID(selectedcrs)=="" or selectedcrs is None) and (previousselectedcrs=="" or previousselectedcrs==0 or previousselectedcrs is None):
            #self.nocrsselected()
            pass
        else:
            #self.dlg.labelselectedcrs.setText(self.CrsId2AuthID(selectedcrs))
            src=self.CrsId2AuthID(selectedcrs).replace('\n','')
            if(not self.buscarEnArchivo(src, "src.txt")):
                this_folder = os.path.dirname(os.path.abspath(__file__))
                file = open(this_folder+"\src.txt", mode='a')
                file.write('\n'+src)
                file.close()
                self.file2Combo("src.txt", self.dlg.combo_src,'')
            self.dlg.combo_src.setCurrentText(src)
        self.dlg.show()
    
    def CrsId2AuthID(self, crsid=0):
        toconvert = QgsCoordinateReferenceSystem()
        if crsid=="" or crsid==0 or crsid is None:
            converted=""
        else:
            toconvert.createFromId(int(crsid), QgsCoordinateReferenceSystem.InternalCrsId)
            converted=toconvert.authid()
        return converted.lower()
    def estatInicial(self):
        '''
        @param self:
        Resteja tots els valors per defecte del plugin: estat inicial.
        '''
        global aux
        global Versio_modul
        global lbl_Cost
        global data
        data=None
        aux = False
        self.dlg.progressBar.setValue(0)
        self.dlg.radio_ws.setChecked(True)
        self.dlg.radio_geom.setChecked(True)
        self.dlg.txt_url.clear()
        self.dlg.txt_url.setPlaceholderText("Introdueix la url del Web Service")
        self.dlg.txt_nomTaula.clear()
        self.dlg.txt_nomTaula.setPlaceholderText("Introdueix el nom que apareixerà a la llegenda")
        self.dlg.text_info.clear()
        self.dlg.combo_ws.clear()
        self.dlg.combo_nom.clear()
        self.dlg.combo_geom.clear()
        self.dlg.combo_lng.clear()
        self.dlg.combo_lat.clear()
        self.dlg.combo_cod.clear()
        self.dlg.combo_src.clear()
        self.dlg.ListaCamps.clear()
        self.dlg.checkbox_tots.setChecked(False)
        
        
        self.file2Combo("default_ws.txt", self.dlg.combo_ws, 'Selecciona un Web Service')
        self.file2Combo("codificacio.txt", self.dlg.combo_cod,'')
        self.file2Combo("src.txt", self.dlg.combo_src,'')
        
        
        self.dlg.versio.setText(Versio_modul)
    
    def buscarEnArchivo(self,target,archivo):
        '''Función para buscar una línea en un archivo'''
        this_folder = os.path.dirname(os.path.abspath(__file__))
        file = open(this_folder+'\\'+archivo)        
        for line in file:
            if (line.replace('\n','')==target):
                file.close()
                return True
        file.close()
        return False
    
        
    def file2Combo(self, archivo, combo, predef):
        '''Llenar combo leyendo datos de un archivo'''
        this_folder = os.path.dirname(os.path.abspath(__file__))
        file = open(this_folder+"\\"+archivo)        
        llista=[]
        if (archivo=="default_ws.txt"):
            for line in file:
                if (line[:3]=="url"):
                    llista.append(line[4:].replace('\n',''))
        else:
            for line in file:
                llista.append(line.replace('\n',''))
        file.close()
        self.ompleCombos(combo, llista, predef, True)
    
    
    def on_click_Sortir(self):
        '''
        Tanca la finestra del plugin 
        '''
        self.estatInicial()
        self.dlg.close()
        
    def on_toggled_radio_ws(self,enabled):
        """Aquesta es una funcio auxiliar que controla la visibilitat de diferents 
        elements de la interficie segons la opcio marcada"""
        if enabled:
            self.dlg.combo_ws.setEnabled(True)
            self.dlg.text_url.setEnabled(False)
            
        else:
            self.dlg.combo_ws.setEnabled(False)
            self.dlg.text_url.setEnabled(True)
            
    def on_toggled_radio_geom(self,enabled):
        """Aquesta es una funcio auxiliar que controla la visibilitat de diferents 
        elements de la interficie segons la opcio marcada"""
        if enabled:
            self.dlg.combo_geom.setEnabled(True)
            self.dlg.combo_lat.setEnabled(False)
            self.dlg.combo_lng.setEnabled(False)
            self.dlg.label_geom.setEnabled(True)
            self.dlg.label_lat.setEnabled(False)
            self.dlg.label_lng.setEnabled(False)
        else:
            self.dlg.combo_geom.setEnabled(False)
            self.dlg.combo_lat.setEnabled(True)
            self.dlg.combo_lng.setEnabled(True)
            self.dlg.label_geom.setEnabled(False)
            self.dlg.label_lat.setEnabled(True)
            self.dlg.label_lng.setEnabled(True)
    
        
    def MouText(self):
        newCursor=QTextCursor(self.dlg.text_info.document())
        newCursor.movePosition(QTextCursor.End)
        self.dlg.text_info.setTextCursor(newCursor)
        QApplication.processEvents()
        

 
    def ompleCombos(self, combo, llista, predef, sort):
        """Aquesta funció omple els combos que li passem per paràmetres"""
        combo.blockSignals (True)
        combo.clear()
        model=QStandardItemModel(combo)
        predefInList = None
        for elem in llista:
            try:
                item = QStandardItem(str(elem))
            except TypeError:
                item = QStandardItem(str(elem))
            model.appendRow(item)
            if elem == predef:
                predefInList = elem
        combo.setModel(model)
        if predef != "":
            if predefInList:
                combo.setCurrentIndex(combo.findText(predefInList))
            else:
                combo.insertItem(0,predef)
                combo.setCurrentIndex(0)
        combo.blockSignals (False)
            
    def on_click_checkbox_tots(self, state):
        if state == QtCore.Qt.Checked:
            self.dlg.ListaCamps.selectAll()
            self.dlg.ListaCamps.setFocus()
        else:
            self.dlg.ListaCamps.clearSelection()
        
    def on_click_Carregar(self):
        global data
        global listFields
        global urlToLoad
        
        self.dlg.combo_nom.clear()
        self.dlg.combo_geom.clear()
        self.dlg.combo_lat.clear()
        self.dlg.combo_lng.clear()
        self.dlg.checkbox_tots.setChecked(False)
        urlToLoad = self.dlg.txt_url.text()
        if(self.dlg.txt_url.text()[-4:]=='.csv'):
            error = self.loadCSV(self.dlg.combo_nom.currentText(), self.dlg.combo_geom.currentText())
            if (error=="Error"):
                return

        else:
            error = self.loadURL(self.dlg.combo_nom.currentText(), self.dlg.combo_geom.currentText())
            if (error=="Error"):
                return
            self.loadFields()
            
        self.ompleCombos(self.dlg.combo_nom, listFields, 'Selecciona un nom', True)
        self.ompleCombos(self.dlg.combo_geom, listFields, 'Selecciona una geometria', True)
        self.ompleCombos(self.dlg.combo_lat, listFields, 'Selecciona una latitud', True) 
        self.ompleCombos(self.dlg.combo_lng, listFields, 'Selecciona una longitud', True)  
        self.cercaCamps()

         
    
    def loadURL(self,nom,geom):
        '''Función para guardar un Web Service de una url en una variable'''
        global data
        global listFields
        global textBox
        global isCSV
        global urlCargada
        global urlToLoad
        
        isCSV=False
        urlCargada=False
        
        self.dlg.combo_nom.clear()
        self.dlg.combo_geom.clear()
        self.dlg.combo_lat.clear()
        self.dlg.combo_lng.clear()
        self.dlg.ListaCamps.clear()
        
        
        self.dlg.progressBar.setValue(50) 
        textBox = u'Accedint a la url '+urlToLoad+'\n'
        self.dlg.text_info.setText(textBox)
        self.MouText()
        
                
        try:
            with urllib.request.urlopen(urlToLoad,timeout=20) as url:
                data = json.loads(url.read().decode())
        except Exception as ex:
            missatge="La URL no és vàlida"
            if (type(ex).__name__=='timeout'):
                missatge="Time out esgotat" 
            print (missatge)
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", missatge)
            self.dlg.text_info.setText('')
            self.dlg.progressBar.setValue(0)
            return "Error"
        urlCargada=True
        return
    
    
    def loadCSV(self,nom,geom):
        '''Función para guardar un CSV de una url en una variable'''
        global listFields
        global textBox
        global isCSV
        global urlCargada
        global urlToLoad
        global data
        
        isCSV= True
        urlCargada = False
        
        self.dlg.combo_nom.clear()
        self.dlg.combo_geom.clear()
        self.dlg.combo_lat.clear()
        self.dlg.combo_lng.clear()
        self.dlg.ListaCamps.clear()
        
        
        self.dlg.progressBar.setValue(50) 
        textBox = u'Accedint a la url '+urlToLoad+'\n'
        self.dlg.text_info.setText(textBox)
        self.MouText()

        '''Se descarga el CSV y se guarda en una carpeta temporal'''
        filename = os.environ['TMP']+"\WS.csv"
        try:
            self.download_file(urlToLoad, filename)
        except Exception as ex:
            missatge="La URL no és vàlida"
            if (type(ex).__name__=='ConnectTimeout'):
                missatge="Time out esgotat" 
            print (missatge)
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", missatge)
            self.dlg.text_info.setText('')
            self.dlg.progressBar.setValue(0)
            return "Error"
        
            
        self.dlg.progressBar.setValue(80)
        textBox += u'Detectant camps...\n'
        self.dlg.text_info.setText(textBox)
        self.MouText()
        
        '''Se extraen los nombres de campo del CSV'''
        try:
            data=[]
            with open(filename, newline='', encoding=self.dlg.combo_cod.currentText()) as f:
                reader = csv.reader(f)
                for row in reader:
                    data.append(row)
                    break;
                
            listFields = data[0]
        except Exception as ex:
            missatge="La codificació seleccionada no és correcte"
            print (missatge)
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", missatge)
            self.dlg.text_info.setText('')
            self.dlg.progressBar.setValue(0)
            return "Error"
        self.dlg.progressBar.setValue(0)
        textBox += u'Informació obtinguda del CSV\n'
        self.dlg.text_info.setText(textBox)
        self.MouText()
        urlCargada=True
        return
        
        
    def download_file(self, url, filename):
        '''Función para descargar el archivo de la url y guardarlo con el filename'''
        response = requests.get(url,timeout=20)
        # Se comprueba si la respuesta es ok (200)
        if response.status_code == 200:
            with open(filename, 'wb') as file:
                for chunk in response:
                    file.write(chunk)
        
        
    def loadFields(self):
        '''Función para detectar todos los campos que aparecen en la variable obtenida de cargar un Web Service'''
        global data
        global textBox
        global listFields
        
        self.dlg.progressBar.setValue(80)
        textBox += u'Detectant camps...\n'
        self.dlg.text_info.setText(textBox)
        self.MouText()
        
        
        listFields = []
        z=0
        for x in range(len(data['equipaments'])):
            for y in data['equipaments'][x]:
                if(y=='id'):
                    if not(y+'_'+str(z) in listFields):
                        listFields.append(y+'_'+str(z))
                else:
                    if not(y in listFields):
                        listFields.append(y)
                z=z+1
        
        self.dlg.progressBar.setValue(0)
        textBox += u'Informació obtinguda del Web Service\n'
        self.dlg.text_info.setText(textBox)
        self.MouText()   
    
    def on_click_Veure(self):
        '''Función para visualizar la url en el navegador predeterminado del SO'''
        webbrowser.open_new(self.dlg.txt_url.text())
            
            
    def searchNomGeomCodSrcInFile(self):
        '''Función que devuelve los valores de nombre, geometría, codificación y src de la url predeterminada que se está consultando.
        Dichos valores están guardados en un fichero llamado default_ws.txt, localizado en la raíz del proyecto'''
        this_folder = os.path.dirname(os.path.abspath(__file__))
        file = open(this_folder+"\default_ws.txt") 
        nom=None
        geometria=None  
        cod=None
        src=None     
        cont=0
        for line in file:
            if (line[4:].replace('\n','')==self.dlg.combo_ws.currentText()):
                cont=cont+1
            elif (cont==1):
                nom = line[4:].replace('\n','')
                cont=cont+1
            elif (cont==2):
                geometria = line[4:].replace('\n','')
                cont=cont+1
            elif (cont==3):
                cod = line[4:].replace('\n','')
                cont=cont+1
            elif (cont==4):
                src = line[4:].replace('\n','')
                break
        file.close()     
        return(nom,geometria,cod,src)
    
    
    def controlErrorsInput(self):
        '''
        Aquesta funció s'encarrega de controlar que quan comenci el càlcul
        totes les entrades de dades estiguin omplertes i siguin correctes
        '''
        global urlCargada
        errors = []
        
        if self.dlg.txt_nomTaula.text() == '':
            errors.append('No hi ha cap nom')
        if self.dlg.radio_ws.isChecked():
            if self.dlg.combo_ws.currentText() == 'Selecciona un Web Service':
                errors.append('No hi ha cap Web Service seleccionat')
        else:
            if not urlCargada:
                errors.append('No hi ha cap URL carregada')
            if self.dlg.combo_nom.currentText() == 'Selecciona un nom':
                errors.append('No hi ha cap "Camp nom" seleccionat')
            if self.dlg.radio_geom.isChecked():
                if self.dlg.combo_geom.currentText() == 'Selecciona una geometria':
                    errors.append('No hi ha cap camp de geometria seleccionat')
            else:
                if self.dlg.combo_lat.currentText() == 'Selecciona una latitud':
                    errors.append('No hi ha cap camp de latitud seleccionat')
                if self.dlg.combo_lng.currentText() == 'Selecciona una longitud':
                    errors.append('No hi ha cap camp de longitud seleccionat')
        return errors
    
    def cercaCamps(self):
        """Esta función llena la LlistaCamps de los nombres de los campos obtenidos"""
        global listFields
        self.dlg.ListaCamps.clear()
        
        for field in listFields:
            self.dlg.ListaCamps.addItem(field)
            
        
    
    def comprobarValidez(self,vlayer):        
        #processing.algorithmHelp("native:shortestpathpointtolayer")
        parameters= {'ERROR_OUTPUT' : 'memory:',
                     'INPUT_LAYER' : vlayer,
                     'INVALID_OUTPUT' : 'memory:',
                     'METHOD' : 1,
                     'VALID_OUTPUT' : 'memory:'}
        
        result = processing.run('qgis:checkvalidity',parameters)
        
        return result['VALID_OUTPUT']

    
    def getIndexOfField(self,vlayer,field):
        '''Función para obtener el índice de un campo de un vlayer'''
        fields = vlayer.fields()
        for x in range(len(fields)):
            if(fields[x].displayName()==field):
                return x
        return -1
    
    def on_click_Inici(self):
        global lbl_Cost
        global data
        global listFields
        global isCSV
        global urlToLoad
    
        
        '''Tratamiento de errores'''
        llistaErrors = self.controlErrorsInput()
        if len(llistaErrors) > 0:
            llista = "Llista d'errors:\n\n"
            for i in range (0,len(llistaErrors)):
                llista += ("- "+llistaErrors[i] + '\n')
            QMessageBox.information(None, "Error", llista)
            return
        
        
        textBox = u'INICI DEL PROCÉS\n\n'
        self.dlg.text_info.setText(textBox)
        self.MouText()
        
        '''Obtención de Nom y Geometria'''
        if self.dlg.radio_ws.isChecked():
            campNom,campGeometria,campCod,campSrc=self.searchNomGeomCodSrcInFile()
            #En futuras implementaciones se pueden añadir los campos de latitud y longitud en el archivo.
            campLat=None
            campLng=None
            urlToLoad=self.dlg.combo_ws.currentText()
            if(urlToLoad[-4:]=='.csv'):
                error = self.loadCSV(campNom, campGeometria)
                if (error=="Error"):
                    return
    
            else:
                error = self.loadURL(campNom, campGeometria)
                if (error=="Error"):
                    return
                self.loadFields()
        else:
            campNom = self.dlg.combo_nom.currentText()
            campGeometria = self.dlg.combo_geom.currentText()
            campCod=self.dlg.combo_cod.currentText()
            campSrc=self.dlg.combo_src.currentText()
            campLat=self.dlg.combo_lat.currentText()
            campLng=self.dlg.combo_lng.currentText()
        
        if isCSV:
            '''Tratamiento para CSV'''
            self.dlg.progressBar.setValue(60)
            textBox += u'Generant capa vectorial...\n'
            self.dlg.text_info.setText(textBox)
            self.MouText()
            if self.dlg.radio_geom.isChecked():
                file = 'file:///'+os.environ['TMP']+'\WS.csv?encoding=%s&delimiter=%s&wktField=%s&crs=%s' % (campCod,",", campGeometria,campSrc) 
            else:
                file = 'file:///'+os.environ['TMP']+'\WS.csv?encoding=%s&delimiter=%s&xField=%s&yField=%s&crs=%s' % (campCod,",", campLng, campLat,campSrc)
            vlayergeom = QgsVectorLayer(file, self.dlg.txt_nomTaula.text(),'delimitedtext')
            try:
                vlayergeom = self.comprobarValidez(vlayergeom) #Sirve tanto para comprobar la corrección del CSV como para pasar el layer a memoria
            except Exception as ex:
                missatge="La geometria seleccionada no és correcte"
                print (missatge)
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", missatge)
                self.dlg.text_info.setText('')
                self.dlg.progressBar.setValue(0)
                return "Error"
            vlayergeom.setName(self.dlg.txt_nomTaula.text())
            
            
            self.dlg.progressBar.setValue(80)
            textBox += u'Adaptant camps...\n'
            self.dlg.text_info.setText(textBox)
            self.MouText()
            
            '''Se renombra el campo de nombre y se añade un id'''
            vlayergeom.startEditing()
            fields = vlayergeom.fields()
            for x in range(len(fields)):
                if(campNom in fields[x].displayName()):
                    vlayergeom.renameAttribute(x,'Nom')
                    break;
            vlayergeom.addAttribute(QgsField('id', QVariant.Int))
            vlayergeom.commitChanges()
            
            '''Se autonumera el id'''
            features = vlayergeom.getFeatures()
            vlayergeom.startEditing()
            x=1
            for feature in features:
                vlayergeom.changeAttributeValue(feature.id(),self.getIndexOfField(vlayergeom,"id"),x)
                x=x+1
            vlayergeom.commitChanges()
            
            
            
        else:
            '''Tratamiento para no CSV'''
            listEquipaments = data['equipaments'] #lista de dicts
            listEquipamentsGeometria = []
            
            
            '''Se descartan las entidades que no dispongan de los campos campGeometria y campNom'''
            textBox += u'Preparant les dades...\n'
            self.dlg.text_info.setText(textBox)
            self.MouText()
            
    
            for x in range(len(listEquipaments)):
                if self.dlg.radio_geom.isChecked():
                    if campGeometria in listEquipaments[x] and campNom in listEquipaments[x]:
                        listEquipamentsGeometria.append(listEquipaments[x])
                else:
                    if self.dlg.combo_lng.currentText() in listEquipaments[x] and self.dlg.combo_lat.currentText() in listEquipaments[x] and campNom in listEquipaments[x]:
                            listEquipamentsGeometria.append(listEquipaments[x])
                    
            '''Se crea el vlayer'''
            self.dlg.progressBar.setValue(50)
            textBox += u'Creació de la taula '+self.dlg.txt_nomTaula.text()+'\n'
            self.dlg.text_info.setText(textBox)
            self.MouText()
            
            if campNom in listFields:
                listFields.remove(campNom)
            if campGeometria in listFields:
                listFields.remove(campGeometria)  
            vlayergeom = self.createVlayer(listFields,campSrc)
            
            
            '''Se añaden las entidades al vlayer'''
            self.dlg.progressBar.setValue(60)
            textBox += u'Inserint dades...\n'
            self.dlg.text_info.setText(textBox)
            self.MouText()
        
            vlayergeom = self.fillVlayer(listEquipamentsGeometria,listFields,vlayergeom,campNom,campGeometria,campLng,campLat)
            if(vlayergeom=="Error"):
                return
        
        '''Se borran los campos no seleccionados''' 
        if not self.dlg.radio_ws.isChecked():
            llista_sel=[]    
            if (len(self.dlg.ListaCamps.selectedItems())>0):
                for item in self.dlg.ListaCamps.selectedItems():
                    llista_sel.append(item.text())
            
            vlayergeom.startEditing()
            for elem in listFields:
                if elem not in llista_sel:
                    vlayergeom.deleteAttribute(self.getIndexOfField(vlayergeom,elem))
            
            vlayergeom.commitChanges()
       
       
        '''Se representa en pantalla'''
        QgsProject.instance().addMapLayer(vlayergeom,False)
        root = QgsProject.instance().layerTreeRoot()
        myLayerNode=QgsLayerTreeLayer(vlayergeom)
        root.insertChildNode(0,myLayerNode)
        myLayerNode.setCustomProperty("showFeatureCount", True)
        
        self.dlg.progressBar.setValue(100)
        textBox += u'\nProcés finalitzat.\n'
        self.dlg.text_info.setText(textBox)
        self.MouText()
        

    def createVlayer(self, listFields,campSrc):
        '''Función para crear el vlayer con un campo de id, un campo de nom, los campos pasados por el parámetro lisFields y el parámetro campSrc para crear la geometría'''
        vlayer = QgsVectorLayer("Point?crs="+campSrc, self.dlg.txt_nomTaula.text(), "memory")
        
        vlayer.startEditing()
        vlayer.addAttribute(QgsField('id', QVariant.Int))
        vlayer.addAttribute(QgsField('Nom', QVariant.String))
        for x in range(len(listFields)):
            vlayer.addAttribute(QgsField(listFields[x], QVariant.String))
        vlayer.commitChanges()
        return vlayer
    
    
    def fillVlayer(self, llistaFeatures, llistaCamps, vlayer, campNom, campGeometria,campLng,campLat):
        '''Función para llenar un vlayer vació con la lista de features y fields que se pasen por parámetro, siendo necesario indicar el nombre de campNom
        y, por otra parte, indicar el campo de geometría o los de longitud y latitud.'''
        for x in range(len(llistaFeatures)):
            try:
                if self.dlg.radio_geom.isChecked():
                    coordinates = llistaFeatures[x][campGeometria].replace("POINT ","")
                    xCoord = coordinates.split(" ")[0][1:]
                    yCoord = coordinates.split(" ")[1][:-1]
                else:
                    xCoord = llistaFeatures[x][campLng]
                    yCoord = llistaFeatures[x][campLat]
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(float(xCoord),float(yCoord))))
            except Exception as ex:
                missatge="El camp de geometria no és correcte"
                print (missatge)
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", missatge)
                self.dlg.text_info.setText('')
                self.dlg.progressBar.setValue(0)
                return "Error"
            
            
            values=[]
            values.append(QVariant(x))
            values.append(QVariant(str(llistaFeatures[x][campNom])))
            for y in range(len(llistaCamps)):
                if(llistaCamps[y]!='id' and llistaCamps[y]!=campNom and llistaCamps[y]!=campGeometria):
                    if llistaCamps[y] in llistaFeatures[x]:
                        values.append(QVariant(str(llistaFeatures[x][llistaCamps[y]])))
                    else:
                        values.append(QVariant(str('')))   
                    
            
            feature.setAttributes(values)
            vlayer.startEditing()
            vlayer.addFeature(feature)
            vlayer.commitChanges()
        return vlayer
    
    